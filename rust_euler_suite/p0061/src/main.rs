// <p>Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:</p>
// <table><tr><td>Triangle</td>
// <td> </td>
// <td>$P_{3,n}=n(n+1)/2$</td>
// <td> </td>
// <td>$1, 3, 6, 10, 15, \dots$</td>
// </tr><tr><td>Square</td>
// <td> </td>
// <td>$P_{4,n}=n^2$</td>
// <td> </td>
// <td>$1, 4, 9, 16, 25, \dots$</td>
// </tr><tr><td>Pentagonal</td>
// <td> </td>
// <td>$P_{5,n}=n(3n-1)/2$</td>
// <td> </td>
// <td>$1, 5, 12, 22, 35, \dots$</td>
// </tr><tr><td>Hexagonal</td>
// <td> </td>
// <td>$P_{6,n}=n(2n-1)$</td>
// <td> </td>
// <td>$1, 6, 15, 28, 45, \dots$</td>
// </tr><tr><td>Heptagonal</td>
// <td> </td>
// <td>$P_{7,n}=n(5n-3)/2$</td>
// <td> </td>
// <td>$1, 7, 18, 34, 55, \dots$</td>
// </tr><tr><td>Octagonal</td>
// <td> </td>
// <td>$P_{8,n}=n(3n-2)$</td>
// <td> </td>
// <td>$1, 8, 21, 40, 65, \dots$</td>
// </tr></table><p>The ordered set of three $4$-digit numbers: $8128$, $2882$, $8281$, has three interesting properties.</p>
// <ol><li>The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).</li>
// <li>Each polygonal type: triangle ($P_{3,127}=8128$), square ($P_{4,91}=8281$), and pentagonal ($P_{5,44}=2882$), is represented by a different number in the set.</li>
// <li>This is the only set of $4$-digit numbers with this property.</li>
// </ol><p>Find the sum of the only ordered set of six cyclic $4$-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.</p>

use lib_number_sequences::polygonal::Polygonal;

type CyclicPolygonalList = Vec<u32>;
type CyclicPolygonalLists = Vec<CyclicPolygonalList>;

fn main() {
    // idea:
    // - pre-compute all 4-digit P_{i,n} for i = 3, .., 8
    // - remove all numbers that of the kind ..0. since they cannot be cyclic with four digit numbers
    // - iterate over all octagonal numbers
    //   - check if from any of the other polygonal numbers one can be used to extend the set s.t. it is cyclic
    //   - if possible recurse with these polygonal numbers removed
    //   - this should guarantee  that from each set one number is used

    let four_digit_polygonals = compute_all_four_digit_polygonal_numbers();
    let cyclic_polygonals = get_non_cyclic_removed_polygonials(four_digit_polygonals);
    cyclic_polygonals.iter()
        .for_each(|x| println!("{:?}", x));

    let cyclic_polygonals_refs: Vec<&CyclicPolygonalList> = cyclic_polygonals.iter().collect();
    let four_digit_cyclic_gonals = extend_current_cyclic_gonals_list(&CyclicPolygonalList::new(), &cyclic_polygonals_refs);

    if four_digit_cyclic_gonals.is_some() {
        println!("Found 6 cyclic polygonals: {:?}", four_digit_cyclic_gonals.as_ref().unwrap());
        let sum: u32 = four_digit_cyclic_gonals.unwrap().iter().sum();
        println!("Sum: {}", sum);
    }
}

fn compute_all_four_digit_polygonal_numbers() -> CyclicPolygonalLists {
    (3..=8)
        .into_iter()
        .map(|x| compute_four_digit_polygonal_numbers(x))
        .collect()
}

fn compute_four_digit_polygonal_numbers(gonality: u32) -> Vec<u32> {
    let mut numbers: Vec<u32> = vec![];
    let mut pol = Polygonal::new(gonality, 5);

    while pol.value < 10000 {
        if pol.value >= 1000 {
            numbers.push(pol.value);
        }
        pol = pol.next();
    }

    numbers
}

fn get_non_cyclic_removed_polygonials(four_digit_polygonals: CyclicPolygonalLists) -> CyclicPolygonalLists {
    four_digit_polygonals
        .iter()
        .map(|v| { v
            .iter()
            .filter(|val| *val%100 >= 10 )
            .cloned()
            .collect()
        }).collect()
}


fn extend_current_cyclic_gonals_list(current_cyclic_gonals: &CyclicPolygonalList, remaining_cyclic_polygonals: &Vec<&CyclicPolygonalList>) 
    -> Option<CyclicPolygonalList>
{
    if current_cyclic_gonals.len() == 6 {
        if check_four_digit_cyclic(current_cyclic_gonals[5], current_cyclic_gonals[0]) {
            return Some(current_cyclic_gonals.clone())
        }
        else {
            println!("6 almost cyclic polygonals: {:?}", current_cyclic_gonals);
        }
    }
    else {
        for (nlist, current_list) in remaining_cyclic_polygonals.iter().enumerate() {
            let lists_without_current = remaining_cyclic_polygonals
                .iter()
                .enumerate()
                .filter(|(nwo, _)| *nwo != nlist)
                .map(|(_,l)| *l)
                .collect();
            for num_check in *current_list {
                if current_cyclic_gonals.is_empty() || check_four_digit_cyclic(*current_cyclic_gonals.last().unwrap(), *num_check) {
                    let mut new_gonals = current_cyclic_gonals.clone();
                    new_gonals.push(*num_check);

                    let have_gonals = extend_current_cyclic_gonals_list(&new_gonals, &lists_without_current);
                    if have_gonals.is_some() {
                        return have_gonals
                    }
                }
            }
        }
    }

    None
}

fn check_four_digit_cyclic(first: u32, second: u32) -> bool {
    (first%100) == (second/100)
}


#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_check_four_digit_cyclic() {
        assert_eq!(check_four_digit_cyclic(1234, 1234), false);
        assert_eq!(check_four_digit_cyclic(1234, 3456), true);
        assert_eq!(check_four_digit_cyclic(1011, 1100), true);
    }
}

// Found 6 cyclic polygonals: [8256, 5625, 2512, 1281, 8128, 2882]
// Sum: 28684

